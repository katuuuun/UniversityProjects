.data
    prompt_num: .asciiz "Enter a number: "
    prompt_min: .asciiz "Enter the minimum value: "
    prompt_max: .asciiz "Enter the maximum value: "
    result_msg: .asciiz "Sum: "
    invalid_msg: .asciiz "Invalid number! Number is out of range."

.text
.globl main

main:
    # Вводим минимальное значение
    li $v0, 4           # Системный вызов для вывода строки
    la $a0, prompt_min  # Загружаем адрес строки в $a0
    syscall             # Вызываем систему для вывода строки

    li $v0, 5           # Системный вызов для ввода целого числа
    syscall             # Вызываем систему для ввода числа
    move $t0, $v0       # Сохраняем минимальное значение в $t0

    # Вводим максимальное значение
    li $v0, 4           # Системный вызов для вывода строки
    la $a0, prompt_max  # Загружаем адрес строки в $a0
    syscall             # Вызываем систему для вывода строки

    li $v0, 5           # Системный вызов для ввода целого числа
    syscall             # Вызываем систему для ввода числа
    move $t1, $v0       # Сохраняем максимальное значение в $t1

    # Выводим приглашение для ввода числа
    li $v0, 4           # Системный вызов для вывода строки
    la $a0, prompt_num  # Загружаем адрес строки в $a0
    syscall             # Вызываем систему для вывода строки

    # Вводим число с клавиатуры
    li $v0, 5           # Системный вызов для ввода целого числа
    syscall             # Вызываем систему для ввода числа
    move $a0, $v0       # Сохраняем введенное число в $a0

    # Проверяем, что число входит в диапазон
    blt $a0, $t0, invalid_number
    bgt $a0, $t1, invalid_number

    # Инициализируем сумму цифр
    li $t2, 0           # Сумма цифр будет храниться в $t2
    li $t3, 10

compute_sum_loop:
    # Вычисляем остаток от деления на 10
    div $a0, $t3        # Делим содержимое $a0 на 10
    mfhi $t1            # Получаем остаток от деления и сохраняем в $t1

    # Добавляем остаток к сумме
    add $t2, $t2, $t1   # Добавляем остаток к сумме в $t2

    # Делим число на 10
    mflo $a0            # Сохраняем результат деления (целую часть) в $a0

    # Проверяем, равно ли число нулю
    bnez $a0, compute_sum_loop  # Если $a0 != 0, то повторяем вычисления

    # Выводим результат
    li $v0, 4           # Системный вызов для вывода строки
    la $a0, result_msg  # Загружаем адрес строки в $a0
    syscall             # Вызываем систему для вывода строки

    li $v0, 1           # Системный вызов для вывода целого числа
    move $a0, $t2       # Передаем значение суммы в $a0
    syscall             # Вызываем систему для вывода суммы

    # Завершаем программу
    li $v0, 10          # Системный вызов для выхода из программы
    syscall             # Вызываем систему для выхода

invalid_number:
    # Выводим сообщение об ошибке
    li $v0, 4           # Системный вызов для вывода строки
    la $a0, invalid_msg # Загружаем адрес строки в $a0
    syscall             # Вызываем систему для вывода строки

    # Завершаем программу
    li $v0, 10          # Системный вызов для выхода из программы
    syscall             # Вызываем систему для выхода
